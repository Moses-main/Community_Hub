import type { Express, Request } from "express";
import { createServer, type Server } from "http";
import { storage, type ISermonFilter } from "./storage";
import { api } from "@shared/routes";
import { z } from "zod";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import { sendNewMessageNotification } from "./websocket";

// Extend Express Request type to include user
interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    firstName?: string;
    lastName?: string;
    isAdmin?: boolean;
  };
}

// JWT secret (in production, use a secure environment variable)
const JWT_SECRET = process.env.JWT_SECRET || "your-super-secret-jwt-key-change-in-production";

// Authentication schemas
const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
});

const signupSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
  firstName: z.string().min(1),
  lastName: z.string().optional(),
});

// Authentication middleware
const isAuthenticated = async (req: AuthenticatedRequest, res: any, next: any) => {
  console.log('=== AUTH CHECK ===');
  console.log('Cookies:', req.cookies);
  console.log('Auth header:', req.headers.authorization);
  try {
    const token = req.cookies?.token || req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      console.log('No token found');
      return res.status(401).json({ message: "No token provided" });
    }

    console.log('Token found, verifying...');
    const decoded = jwt.verify(token, JWT_SECRET) as any;
    const user = await storage.getUserById(decoded.userId);
    
    if (!user) {
      console.log('User not found');
      return res.status(401).json({ message: "Invalid token" });
    }

    console.log('User authenticated:', user.email, user.role);
    req.user = {
      id: user.id,
      email: user.email!,
      firstName: user.firstName || undefined,
      lastName: user.lastName || undefined,
      isAdmin: user.email === 'admin@wccrm.com' // Simple admin check
    };
    
    next();
  } catch (error) {
    console.log('Auth error:', error);
    return res.status(401).json({ message: "Invalid token" });
  }
};

// Admin middleware
const isAdmin = async (req: AuthenticatedRequest, res: any, next: any) => {
  if (!req.user?.isAdmin) {
    return res.status(403).json({ message: "Admin access required" });
  }
  next();
};

// Roles that can view absent members
const ABSENT_MEMBER_ROLES = ['ADMIN', 'PASTOR', 'PASTORS_WIFE', 'CELL_LEADER', 'USHERS_LEADER'];

// Roles that can send messages to members
const CAN_SEND_MESSAGE_ROLES = ['ADMIN', 'PASTOR', 'PASTORS_WIFE', 'CELL_LEADER', 'USHERS_LEADER', 'PRAYER_TEAM', 'EVANGELISM_TEAM'];

// Middleware to check if user can view absent members
const canViewAbsentMembers = async (req: AuthenticatedRequest, res: any, next: any) => {
  // Check if user is authenticated first
  if (!req.user) {
    return res.status(401).json({ message: "Authentication required" });
  }
  // Allow all authenticated users for now
  return next();
};

// Middleware to check if user can send messages to members
const canSendMessages = async (req: AuthenticatedRequest, res: any, next: any) => {
  console.log('canSendMessages - user:', req.user?.email, 'isAdmin:', req.user?.isAdmin);
  
  if (!req.user) {
    return res.status(401).json({ message: "Authentication required" });
  }
  
  // Allow admin users
  if (req.user.isAdmin) {
    console.log('Admin access granted');
    return next();
  }
  
  // Check user's role from database
  try {
    const user = await storage.getUserById(req.user.id);
    console.log('User role from DB:', user?.role);
    if (user && CAN_SEND_MESSAGE_ROLES.includes(user.role)) {
      return next();
    }
  } catch (err) {
    console.error('Error checking user role:', err);
  }
  
  console.log('Permission denied');
  return res.status(403).json({ message: "Permission denied to send messages" });
};

export async function registerRoutes(
  httpServer: Server,
  app: Express,
): Promise<Server> {
  // === AUTHENTICATION ROUTES ===

  // Get current user
  app.get("/api/auth/user", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    const user = await storage.getUserById(req.user!.id);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    res.json({
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      phone: user.phone,
      address: user.address,
      houseFellowship: user.houseFellowship,
      houseCellLocation: user.houseCellLocation,
      parish: user.parish,
      career: user.career,
      stateOfOrigin: user.stateOfOrigin,
      birthday: user.birthday,
      twitterHandle: user.twitterHandle,
      instagramHandle: user.instagramHandle,
      facebookHandle: user.facebookHandle,
      linkedinHandle: user.linkedinHandle,
      role: user.role,
      isAdmin: user.email === 'admin@wccrm.com',
      createdAt: user.createdAt,
    });
  });

  // === GDPR ROUTES ===

  // Export member data (for GDPR data portability)
  app.get("/api/gdpr/export", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      const attendance = await storage.getAttendanceByUser(userId);
      const rsvps = await storage.getUserRsvps(userId);

      const exportData = {
        profile: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          phone: user.phone,
          address: user.address,
          houseFellowship: user.houseFellowship,
          houseCellLocation: user.houseCellLocation,
          parish: user.parish,
          career: user.career,
          stateOfOrigin: user.stateOfOrigin,
          birthday: user.birthday,
          twitterHandle: user.twitterHandle,
          instagramHandle: user.instagramHandle,
          facebookHandle: user.facebookHandle,
          linkedinHandle: user.linkedinHandle,
          role: user.role,
          createdAt: user.createdAt,
        },
        attendance: attendance.map(a => ({
          serviceType: a.serviceType,
          serviceName: a.serviceName,
          serviceDate: a.serviceDate,
          attendanceType: a.attendanceType,
          isOnline: a.isOnline,
          checkInTime: a.checkInTime,
        })),
        eventRsvps: rsvps.map(r => ({
          eventId: r.eventId,
          addedToCalendar: r.addedToCalendar,
          createdAt: r.createdAt,
        })),
        exportedAt: new Date().toISOString(),
      };

      res.setHeader("Content-Type", "application/json");
      res.setHeader("Content-Disposition", `attachment; filename=my-data-${new Date().toISOString().split("T")[0]}.json`);
      res.json(exportData);
    } catch (err) {
      console.error("Error exporting data:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete member data (for GDPR right to erasure)
  app.delete("/api/gdpr/delete", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const { confirmation } = req.body;

      if (confirmation !== "DELETE_MY_DATA") {
        return res.status(400).json({ 
          message: "Please type 'DELETE_MY_DATA' to confirm deletion" 
        });
      }

      // In a real implementation, you would:
      // 1. Anonymize or delete personal data
      // 2. Keep minimal data for legal requirements
      // 3. Notify admin
      
      // For now, we'll just return a success message
      // In production, implement actual data deletion
      
      res.json({ 
        message: "Data deletion request submitted. Your data will be removed within 30 days." 
      });
    } catch (err) {
      console.error("Error deleting data:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get privacy settings
  app.get("/api/gdpr/privacy", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = await storage.getUserById(userId);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      res.json({
        dataRetentionEnabled: true,
        marketingConsent: false,
        attendanceVisibility: "private",
        profileVisibility: "members",
      });
    } catch (err) {
      console.error("Error fetching privacy settings:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update privacy settings
  app.put("/api/gdpr/privacy", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const { marketingConsent, attendanceVisibility, profileVisibility } = req.body;

      // In a real implementation, store these preferences
      res.json({ 
        message: "Privacy settings updated successfully",
        settings: {
          marketingConsent,
          attendanceVisibility,
          profileVisibility,
        }
      });
    } catch (err) {
      console.error("Error updating privacy settings:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Login
  app.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = loginSchema.parse(req.body);
      
      const user = await storage.getUserByEmail(email);
      if (!user || !user.passwordHash) {
        return res.status(401).json({ message: "Invalid credentials" });
      }

      const isValidPassword = await bcrypt.compare(password, user.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ message: "Invalid credentials" });
      }

      const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });
      
      const isProduction = process.env.NODE_ENV === 'production';
      res.cookie('token', token, {
        httpOnly: true,
        secure: isProduction,
        sameSite: isProduction ? 'none' : 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      });

      res.json({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        phone: user.phone,
        address: user.address,
        houseFellowship: user.houseFellowship,
        houseCellLocation: user.houseCellLocation,
        parish: user.parish,
        career: user.career,
        stateOfOrigin: user.stateOfOrigin,
        birthday: user.birthday,
        twitterHandle: user.twitterHandle,
        instagramHandle: user.instagramHandle,
        facebookHandle: user.facebookHandle,
        linkedinHandle: user.linkedinHandle,
        isAdmin: user.email === 'admin@wccrm.com'
      });
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Signup
  app.post("/api/auth/signup", async (req, res) => {
    try {
      const { email, password, firstName, lastName } = signupSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ message: "User already exists" });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 10);
      
      // Create user
      const user = await storage.createUser({
        email,
        passwordHash,
        firstName,
        lastName: lastName || '',
      });

      const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });
      
      const isProduction = process.env.NODE_ENV === 'production';
      res.cookie('token', token, {
        httpOnly: true,
        secure: isProduction,
        sameSite: isProduction ? 'none' : 'lax',
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      });

      res.status(201).json({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        phone: user.phone,
        address: user.address,
        houseFellowship: user.houseFellowship,
        houseCellLocation: user.houseCellLocation,
        parish: user.parish,
        isAdmin: user.email === 'admin@wccrm.com'
      });
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Logout
  app.post("/api/auth/logout", (req, res) => {
    const isProduction = process.env.NODE_ENV === 'production';
    res.clearCookie('token', {
      httpOnly: true,
      secure: isProduction,
      sameSite: isProduction ? 'none' : 'lax',
      path: '/',
    });
    res.json({ message: "Logged out successfully" });
  });

  // Legacy login redirect (for compatibility)
  app.get("/api/login", (req, res) => {
    res.redirect("/auth/login");
  });

  app.get("/api/logout", (req, res) => {
    res.clearCookie('token');
    res.redirect("/");
  });

  // === ADMIN ROUTES ===

  // Get all users (admin only)
  app.get("/api/admin/users", isAuthenticated, isAdmin, async (req, res) => {
    const users = await storage.getAllUsers();
    res.json(users.map(user => ({
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      phone: user.phone,
      address: user.address,
      houseFellowship: user.houseFellowship,
      parish: user.parish,
      role: user.role,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
      isAdmin: user.email === 'admin@wccrm.com'
    })));
  });

  // Get user details (admin only)
  app.get("/api/admin/users/:id", isAuthenticated, isAdmin, async (req, res) => {
    const userId = req.params.id as string;
    const user = await storage.getUserById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    
    res.json({
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      phone: user.phone,
      address: user.address,
      houseFellowship: user.houseFellowship,
      houseCellLocation: user.houseCellLocation,
      parish: user.parish,
      career: user.career,
      stateOfOrigin: user.stateOfOrigin,
      birthday: user.birthday,
      twitterHandle: user.twitterHandle,
      instagramHandle: user.instagramHandle,
      facebookHandle: user.facebookHandle,
      linkedinHandle: user.linkedinHandle,
      role: user.role,
      isVerified: user.isVerified,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
      isAdmin: user.email === 'admin@wccrm.com'
    });
  });

  // Update user role (admin only)
  app.put("/api/admin/users/:id/role", isAuthenticated, isAdmin, async (req, res) => {
    const userId = req.params.id as string;
    const { role } = req.body;
    
    if (!role) {
      return res.status(400).json({ message: "Role is required" });
    }

    const validRoles = [
      'USER', 'ADMIN', 'PASTOR', 'PASTORS_WIFE', 'CHILDREN_LEADER',
      'CHOIRMASTER', 'CHORISTER', 'SOUND_EQUIPMENT', 'SECURITY',
      'USHERS_LEADER', 'USHER', 'SUNDAY_SCHOOL_TEACHER', 'CELL_LEADER',
      'PRAYER_TEAM', 'FINANCE_TEAM', 'TECH_TEAM', 'DECOR_TEAM', 'EVANGELISM_TEAM'
    ];

    if (!validRoles.includes(role)) {
      return res.status(400).json({ message: "Invalid role" });
    }

    const user = await storage.getUserById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    await storage.updateUserRole(userId, role);
    res.json({ message: "Role updated successfully" });
  });

  // Update user profile (admin only)
  app.put("/api/admin/users/:id", isAuthenticated, isAdmin, async (req, res) => {
    const userId = req.params.id as string;
    const { firstName, lastName, phone, address, houseFellowship, career, stateOfOrigin, birthday, twitterHandle, instagramHandle, facebookHandle, linkedinHandle } = req.body;
    
    const user = await storage.getUserById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    await storage.updateUser(userId, {
      firstName: firstName ?? user.firstName,
      lastName: lastName ?? user.lastName,
      phone: phone ?? user.phone,
      address: address ?? user.address,
      houseFellowship: houseFellowship ?? user.houseFellowship,
      career: career ?? user.career,
      stateOfOrigin: stateOfOrigin ?? user.stateOfOrigin,
      birthday: birthday ? new Date(birthday) : user.birthday,
      twitterHandle: twitterHandle ?? user.twitterHandle,
      instagramHandle: instagramHandle ?? user.instagramHandle,
      facebookHandle: facebookHandle ?? user.facebookHandle,
      linkedinHandle: linkedinHandle ?? user.linkedinHandle,
    });

    const updatedUser = await storage.getUserById(userId);
    res.json(updatedUser);
  });

  // === MEMBER ROUTES ===

  // Get current user's profile
  app.get("/api/members/me", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    const user = await storage.getUserById(req.user!.id);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    res.json({
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      phone: user.phone,
      address: user.address,
      houseFellowship: user.houseFellowship,
      houseCellLocation: user.houseCellLocation,
      parish: user.parish,
      role: user.role,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    });
  });

  // Update current user's profile
  app.put("/api/members/me", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    const userId = req.user!.id;
    const { firstName, lastName, phone, address, houseFellowship, parish, houseCellLocation, career, stateOfOrigin, birthday, twitterHandle, instagramHandle, facebookHandle, linkedinHandle } = req.body;
    
    const user = await storage.getUserById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    const updatedUser = await storage.updateUser(userId, {
      firstName: firstName ?? user.firstName,
      lastName: lastName ?? user.lastName,
      phone: phone ?? user.phone,
      address: address ?? user.address,
      houseFellowship: houseFellowship ?? user.houseFellowship,
      parish: parish ?? user.parish,
      houseCellLocation: houseCellLocation ?? user.houseCellLocation,
      career: career ?? user.career,
      stateOfOrigin: stateOfOrigin ?? user.stateOfOrigin,
      birthday: birthday ? new Date(birthday) : user.birthday,
      twitterHandle: twitterHandle ?? user.twitterHandle,
      instagramHandle: instagramHandle ?? user.instagramHandle,
      facebookHandle: facebookHandle ?? user.facebookHandle,
      linkedinHandle: linkedinHandle ?? user.linkedinHandle,
    });

    res.json({
      id: updatedUser.id,
      email: updatedUser.email,
      firstName: updatedUser.firstName,
      lastName: updatedUser.lastName,
      phone: updatedUser.phone,
      address: updatedUser.address,
      houseFellowship: updatedUser.houseFellowship,
      houseCellLocation: updatedUser.houseCellLocation,
      parish: updatedUser.parish,
      career: updatedUser.career,
      stateOfOrigin: updatedUser.stateOfOrigin,
      birthday: updatedUser.birthday,
      twitterHandle: updatedUser.twitterHandle,
      instagramHandle: updatedUser.instagramHandle,
      facebookHandle: updatedUser.facebookHandle,
      linkedinHandle: updatedUser.linkedinHandle,
      role: updatedUser.role,
      createdAt: updatedUser.createdAt,
      updatedAt: updatedUser.updatedAt,
    });
  });

  // Search members (admin only)
  app.get("/api/members/search", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    const query = req.query.q;
    const q = Array.isArray(query) ? query[0] : query;
    if (!q || typeof q !== 'string') {
      return res.status(400).json({ message: "Search query required" });
    }
    const users = await storage.searchUsers(q);
    res.json(users.map(user => ({
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      phone: user.phone,
      address: user.address,
      houseFellowship: user.houseFellowship,
      houseCellLocation: user.houseCellLocation,
      parish: user.parish,
      career: user.career,
      stateOfOrigin: user.stateOfOrigin,
      birthday: user.birthday,
      twitterHandle: user.twitterHandle,
      instagramHandle: user.instagramHandle,
      facebookHandle: user.facebookHandle,
      linkedinHandle: user.linkedinHandle,
      role: user.role,
      createdAt: user.createdAt,
    })));
  });

  // Get all members with pagination (admin only)
  app.get("/api/members", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 50;
      const role = req.query.role as string;
      const houseFellowship = req.query.houseFellowship as string;
      const search = req.query.search as string;

      const allUsers = await storage.getAllUsers();
      
      let filteredUsers = [...allUsers];

      if (role) {
        filteredUsers = filteredUsers.filter(u => u.role === role);
      }

      if (houseFellowship) {
        filteredUsers = filteredUsers.filter(u => u.houseFellowship === houseFellowship);
      }

      if (search) {
        const searchLower = search.toLowerCase();
        filteredUsers = filteredUsers.filter(u => 
          u.firstName?.toLowerCase().includes(searchLower) ||
          u.lastName?.toLowerCase().includes(searchLower) ||
          u.email?.toLowerCase().includes(searchLower) ||
          u.phone?.includes(search) ||
          u.houseFellowship?.toLowerCase().includes(searchLower)
        );
      }

      const total = filteredUsers.length;
      const start = (page - 1) * limit;
      const end = start + limit;
      const paginatedUsers = filteredUsers.slice(start, end);

      res.json({
        members: paginatedUsers.map(user => ({
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          phone: user.phone,
          address: user.address,
          houseFellowship: user.houseFellowship,
          houseCellLocation: user.houseCellLocation,
          parish: user.parish,
          career: user.career,
          stateOfOrigin: user.stateOfOrigin,
          birthday: user.birthday,
          twitterHandle: user.twitterHandle,
          instagramHandle: user.instagramHandle,
          facebookHandle: user.facebookHandle,
          linkedinHandle: user.linkedinHandle,
          role: user.role,
          isAdmin: user.isAdmin,
          createdAt: user.createdAt,
        })),
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
        filters: {
          roles: Array.from(new Set(allUsers.map(u => u.role))),
          houseFellowships: Array.from(new Set(allUsers.map(u => u.houseFellowship).filter(Boolean) as string[])),
        },
      });
    } catch (err) {
      console.error("Error fetching members:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update user's house cell location (admin only)
  app.put("/api/members/:id/house-cell", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    const userIdParam = req.params.id;
    const userId = Array.isArray(userIdParam) ? userIdParam[0] : userIdParam;
    const houseCellLocationInput = req.body.houseCellLocation;
    const houseCellLocation = typeof houseCellLocationInput === 'string' ? houseCellLocationInput : String(houseCellLocationInput);
    
    if (!houseCellLocation || !userId) {
      return res.status(400).json({ message: "House cell location and user ID are required" });
    }

    const user = await storage.getUserById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    const updatedUser = await storage.updateUserHouseCell(userId, houseCellLocation);
    res.json({
      id: updatedUser.id,
      email: updatedUser.email,
      firstName: updatedUser.firstName,
      lastName: updatedUser.lastName,
      houseCellLocation: updatedUser.houseCellLocation,
    });
  });

  // Verify user (admin only)
  app.post("/api/admin/users/:id/verify", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    const userIdParam = req.params.id;
    const userId = Array.isArray(userIdParam) ? userIdParam[0] : userIdParam;
    
    if (!userId) {
      return res.status(400).json({ message: "User ID is required" });
    }

    const user = await storage.getUserById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    const verifiedUser = await storage.verifyUser(userId);
    res.json({
      id: verifiedUser.id,
      email: verifiedUser.email,
      firstName: verifiedUser.firstName,
      lastName: verifiedUser.lastName,
      isVerified: verifiedUser.isVerified,
    });
  });

  // === APP ROUTES ===

  // Branding
  app.get(api.branding.get.path, async (req, res) => {
    const branding = await storage.getBranding();
    if (!branding)
      return res.status(404).json({ message: "Branding not found" });
    res.json(branding);
  });

  app.post(api.branding.update.path, isAuthenticated, async (req, res) => {
    try {
      const input = api.branding.update.input.parse(req.body);
      const updated = await storage.updateBranding(input);
      res.json(updated);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Events
  app.get(api.events.list.path, async (req, res) => {
    const events = await storage.getEvents();
    const eventsWithRsvpCount = await Promise.all(
      events.map(async (event) => {
        const rsvps = await storage.getEventRsvps(event.id);
        return { ...event, rsvpCount: rsvps.length };
      })
    );
    res.json(eventsWithRsvpCount);
  });

  app.get("/api/events/list-with-rsvps", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    const userId = req.user!.id;
    const events = await storage.getEvents();
    const userRsvps = await storage.getUserRsvps(userId);
    const userRsvpEventIds = new Set(userRsvps.map(r => r.eventId));
    
    const eventsWithRsvpCount = await Promise.all(
      events.map(async (event) => {
        const rsvps = await storage.getEventRsvps(event.id);
        return { 
          ...event, 
          rsvpCount: rsvps.length,
          hasRsvped: userRsvpEventIds.has(event.id),
        };
      })
    );
    res.json(eventsWithRsvpCount);
  });

  // Get user's RSVPs - must be BEFORE /:id route
  app.get("/api/events/rsvps", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const rsvps = await storage.getUserRsvps(userId);
      
      // Fetch event details for each RSVP
      const rsvpsWithEvents = await Promise.all(
        rsvps.map(async (rsvp) => {
          const eventId = Number(rsvp.eventId);
          if (isNaN(eventId)) {
            return { ...rsvp, event: null };
          }
          const event = await storage.getEvent(eventId);
          return { ...rsvp, event };
        })
      );
      
      res.json(rsvpsWithEvents);
    } catch (err) {
      console.error("Error fetching RSVPs:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get(api.events.get.path, async (req, res) => {
    const event = await storage.getEvent(Number(req.params.id));
    if (!event) return res.status(404).json({ message: "Event not found" });
    res.json(event);
  });

  app.post(api.events.create.path, isAuthenticated, async (req, res) => {
    try {
      const input = api.events.create.input.parse(req.body);
      // Convert date string to Date object
      const eventData = {
        ...input,
        date: new Date(input.date),
        creatorId: req.user!.id,
      };
      const event = await storage.createEvent(eventData);
      res.status(201).json(event);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.events.rsvp.path, isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const eventId = Number(req.params.id);
      const userId = req.user!.id;
      
      const event = await storage.getEvent(eventId);
      if (!event) {
        return res.status(404).json({ message: "Event not found" });
      }

      const rsvp = await storage.rsvpToEvent(eventId, userId);
      res.json({ message: "RSVP successful", rsvp });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Remove RSVP
  app.delete("/api/events/:id/rsvp", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const eventId = Number(req.params.id);
      const userId = req.user!.id;
      
      await storage.removeRsvp(eventId, userId);
      res.json({ message: "RSVP removed" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Mark event as added to calendar
  app.post("/api/events/:id/calendar", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const eventId = Number(req.params.id);
      const userId = req.user!.id;
      
      const rsvp = await storage.markAddedToCalendar(eventId, userId);
      res.json({ message: "Added to calendar", rsvp });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get event with RSVP count
  app.get("/api/events/:id/with-rsvps", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const eventId = Number(req.params.id);
      const userId = req.user!.id;
      const isAdmin = req.user!.isAdmin;
      
      const event = await storage.getEvent(eventId);
      if (!event) {
        return res.status(404).json({ message: "Event not found" });
      }

      const rsvps = await storage.getEventRsvps(eventId);
      const isCreator = event.creatorId === userId;
      
      // Show RSVPs to creator or admin
      const canViewRsvps = isCreator || isAdmin;
      
      // If can view RSVPs, get user details
      let rsvpsWithUsers = undefined;
      if (canViewRsvps) {
        rsvpsWithUsers = await Promise.all(
          rsvps.map(async (rsvp) => {
            const user = await storage.getUserById(rsvp.userId);
            return {
              ...rsvp,
              user: user ? {
                id: user.id,
                firstName: user.firstName,
                lastName: user.lastName,
                email: user.email,
                phone: user.phone,
              } : null,
            };
          })
        );
      }
      
      res.json({
        ...event,
        rsvpCount: rsvps.length,
        rsvps: rsvpsWithUsers,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update event (auth required)
  app.put("/api/events/:id", isAuthenticated, async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { title, description, date, location, imageUrl } = req.body;
      const input: Partial<{ title: string; description: string; date: Date; location: string; imageUrl?: string }> = {};
      if (title !== undefined) input.title = title;
      if (description !== undefined) input.description = description;
      if (date !== undefined) input.date = new Date(date);
      if (location !== undefined) input.location = location;
      if (imageUrl !== undefined) input.imageUrl = imageUrl;
      const event = await storage.updateEvent(id, input);
      res.json(event);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete event
  app.delete("/api/events/:id", isAuthenticated, async (req, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteEvent(id);
      res.json({ message: "Event deleted successfully" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Send event reminder to RSVPs (admin only)
  app.post("/api/events/:id/remind", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const event = await storage.getEvent(id);
      if (!event) {
        return res.status(404).json({ message: "Event not found" });
      }

      const rsvps = await storage.getEventRsvps(id);
      if (rsvps.length === 0) {
        return res.json({ message: "No RSVPs to send reminders to" });
      }

      // Get user details for each RSVP
      const userIds = rsvps.map(r => r.userId);
      const users = await Promise.all(userIds.map(uid => storage.getUserById(uid)));
      
      // In production, integrate with FCM or email service
      // For now, we'll just return success with the list
      const reminderResult = users
        .filter(u => u && u.email)
        .map(u => ({
          userId: u!.id,
          email: u!.email,
          message: `Reminder: ${event.title} is coming up on ${new Date(event.date).toLocaleDateString()}`
        }));

      res.json({ 
        message: `Reminder prepared for ${reminderResult.length} attendees`,
        recipients: reminderResult,
        event: {
          id: event.id,
          title: event.title,
          date: event.date,
          location: event.location
        }
      });
    } catch (err) {
      console.error("Error sending reminder:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get event analytics
  app.get("/api/events/:id/analytics", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const event = await storage.getEvent(id);
      if (!event) {
        return res.status(404).json({ message: "Event not found" });
      }

      const rsvps = await storage.getEventRsvps(id);
      
      const eventDate = event.date || new Date();
      
      // Calculate analytics
      const analytics = {
        totalRsvps: rsvps.length,
        addedToCalendar: rsvps.filter(r => r.addedToCalendar).length,
        recentRsvps: rsvps.filter(r => {
          const rsvpDate = r.createdAt ? new Date(r.createdAt) : new Date();
          const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
          return rsvpDate > dayAgo;
        }).length,
        eventDate: event.date,
        isPast: eventDate < new Date(),
        daysUntil: Math.ceil((eventDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24))
      };

      res.json(analytics);
    } catch (err) {
      console.error("Error fetching analytics:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Sermons
  app.get(api.sermons.list.path, async (req, res) => {
    const { speaker, series, status, search } = req.query;
    const filter: ISermonFilter = {};
    
    if (speaker) filter.speaker = speaker as string;
    if (series) filter.series = series as string;
    if (search) filter.search = search as string;
    if (status === 'upcoming') filter.isUpcoming = true;
    if (status === 'past') filter.isUpcoming = false;
    
    const sermons = await storage.getSermons(filter);
    res.json(sermons);
  });

  app.get(api.sermons.get.path, async (req, res) => {
    const sermon = await storage.getSermon(Number(req.params.id));
    if (!sermon) return res.status(404).json({ message: "Sermon not found" });
    res.json(sermon);
  });

  // Share sermon - returns social media share links
  app.get("/api/sermons/:id/share", async (req, res) => {
    const sermon = await storage.getSermon(Number(req.params.id));
    if (!sermon) return res.status(404).json({ message: "Sermon not found" });
    
    const baseUrl = process.env.BASE_URL || `https://${req.get('host')}`;
    const sermonUrl = `${baseUrl}/sermons/${sermon.id}`;
    const sermonTitle = encodeURIComponent(sermon.title);
    const sermonDescription = sermon.description ? encodeURIComponent(sermon.description.substring(0, 100)) : '';
    
    const shareLinks = {
      x: `https://twitter.com/intent/tweet?text=${sermonTitle}&url=${encodeURIComponent(sermonUrl)}`,
      whatsapp: `https://wa.me/?text=${sermonTitle}%20${encodeURIComponent(sermonUrl)}`,
      email: `mailto:?subject=${sermonTitle}&body=${sermonDescription}%20${encodeURIComponent(sermonUrl)}`,
      facebook: `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(sermonUrl)}`,
      instagram: `https://www.instagram.com/`,
      tiktok: `https://www.tiktok.com/`,
      copyLink: sermonUrl
    };
    
    res.json(shareLinks);
  });

  // Download sermon audio/video
  app.get("/api/sermons/:id/download", async (req, res) => {
    const sermon = await storage.getSermon(Number(req.params.id));
    if (!sermon) return res.status(404).json({ message: "Sermon not found" });
    
    const { type } = req.query;
    let downloadUrl = null;
    let filename = '';
    
    if (type === 'video' && sermon.videoUrl) {
      downloadUrl = sermon.videoUrl;
      filename = `${sermon.title}-video.mp4`;
    } else if (type === 'audio' && sermon.audioUrl) {
      downloadUrl = sermon.audioUrl;
      filename = `${sermon.title}-audio.mp3`;
    } else if (!type) {
      if (sermon.audioUrl) {
        downloadUrl = sermon.audioUrl;
        filename = `${sermon.title}-audio.mp3`;
      } else if (sermon.videoUrl) {
        downloadUrl = sermon.videoUrl;
        filename = `${sermon.title}-video.mp4`;
      }
    }
    
    if (!downloadUrl) return res.status(404).json({ message: "No download available" });
    
    res.json({ url: downloadUrl, filename, title: sermon.title });
  });

  // Admin only: Create sermon
  app.post(api.sermons.create.path, isAuthenticated, isAdmin, async (req, res) => {
    try {
      const input = api.sermons.create.input.parse(req.body);
      const sermon = await storage.createSermon(input);
      res.status(201).json(sermon);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update sermon (admin only)
  app.put("/api/sermons/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { title, speaker, date, topic, videoUrl, videoFilePath, audioUrl, audioFilePath, series, description, thumbnailUrl, isUpcoming } = req.body;
      const input: Partial<{ title: string; speaker: string; date: Date; topic?: string; videoUrl?: string; videoFilePath?: string; audioUrl?: string; audioFilePath?: string; series?: string; description?: string; thumbnailUrl?: string; isUpcoming?: boolean }> = {};
      if (title !== undefined) input.title = title;
      if (speaker !== undefined) input.speaker = speaker;
      if (date !== undefined) input.date = new Date(date);
      if (topic !== undefined) input.topic = topic;
      if (videoUrl !== undefined) input.videoUrl = videoUrl;
      if (videoFilePath !== undefined) input.videoFilePath = videoFilePath;
      if (audioUrl !== undefined) input.audioUrl = audioUrl;
      if (audioFilePath !== undefined) input.audioFilePath = audioFilePath;
      if (series !== undefined) input.series = series;
      if (description !== undefined) input.description = description;
      if (thumbnailUrl !== undefined) input.thumbnailUrl = thumbnailUrl;
      if (isUpcoming !== undefined) input.isUpcoming = isUpcoming;
      const sermon = await storage.updateSermon(id, input);
      res.json(sermon);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete sermon (admin only)
  app.delete("/api/sermons/:id", isAuthenticated, isAdmin, async (req, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteSermon(id);
      res.json({ message: "Sermon deleted successfully" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Prayer Requests
  app.get(api.prayer.list.path, async (req, res) => {
    const requests = await storage.getPrayerRequests();
    res.json(requests);
  });

  // Get current user's prayer requests
  app.get("/api/prayer-requests/me", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    const allRequests = await storage.getPrayerRequests();
    const userRequests = allRequests.filter(r => r.userId === req.user?.id);
    res.json(userRequests);
  });

  // Create prayer request - NO auth required (open to all)
  app.post(api.prayer.create.path, async (req, res) => {
    try {
      const input = api.prayer.create.input.parse(req.body);
      // Try to get user ID from auth if available, otherwise allow anonymous
      let userId: string | undefined;
      try {
        const token = req.cookies?.token || req.headers.authorization?.replace('Bearer ', '');
        if (token) {
          const decoded = jwt.verify(token, JWT_SECRET) as any;
          userId = decoded.userId;
        }
      } catch (e) {
        // Not authenticated, that's fine - allow anonymous requests
      }
      
      const requestWithUser = { ...input, userId };
      const request = await storage.createPrayerRequest(requestWithUser);
      res.status(201).json(request);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.prayer.pray.path, async (req, res) => {
    const updated = await storage.incrementPrayCount(Number(req.params.id));
    if (!updated) return res.status(404).json({ message: "Request not found" });
    res.json(updated);
  });

  // Mark prayer request as answered (owner or admin)
  app.post("/api/prayer-requests/:id/answer", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const prayerRequest = await storage.getPrayerRequestById(id);
      if (!prayerRequest) {
        return res.status(404).json({ message: "Prayer request not found" });
      }
      
      // Check if user is owner or admin
      if (prayerRequest.userId !== req.user!.id && !req.user!.isAdmin) {
        return res.status(403).json({ message: "Not authorized" });
      }

      const updated = await storage.updatePrayerRequest(id, { isAnswered: true });
      res.json(updated);
    } catch (err) {
      console.error("Error marking prayer request as answered:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete prayer request (owner or admin)
  app.delete("/api/prayer-requests/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const prayerRequest = await storage.getPrayerRequestById(id);
      if (!prayerRequest) {
        return res.status(404).json({ message: "Prayer request not found" });
      }
      
      // Check if user is owner or admin
      if (prayerRequest.userId !== req.user!.id && !req.user!.isAdmin) {
        return res.status(403).json({ message: "Not authorized" });
      }

      await storage.deletePrayerRequest(id);
      res.json({ message: "Prayer request deleted" });
    } catch (err) {
      console.error("Error deleting prayer request:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get prayer wall stats
  app.get("/api/prayer-requests/stats", async (req, res) => {
    try {
      const requests = await storage.getPrayerRequests();
      const totalPrayers = requests.reduce((sum, r) => sum + (r.prayCount || 0), 0);
      const answered = requests.filter(r => r.isAnswered).length;
      const active = requests.filter(r => !r.isAnswered).length;
      
      res.json({
        totalRequests: requests.length,
        totalPrayers,
        answered,
        active,
        recentlyAnswered: requests.filter(r => {
          if (!r.isAnswered || !r.answeredAt) return false;
          const answeredDate = new Date(r.answeredAt);
          const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
          return answeredDate > weekAgo;
        }).length
      });
    } catch (err) {
      console.error("Error fetching prayer stats:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Donations
  app.post(api.donations.create.path, async (req, res) => {
    try {
      const input = api.donations.create.input.parse(req.body);
      const donation = await storage.createDonation(input);
      res.status(201).json(donation);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all fundraising campaigns
  app.get("/api/fundraising", async (req, res) => {
    try {
      const activeOnly = req.query.active === "true";
      const campaigns = await storage.getFundraisingCampaigns(activeOnly);
      res.json(campaigns);
    } catch (err) {
      console.error("Error fetching campaigns:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single fundraising campaign
  app.get("/api/fundraising/:id", async (req, res) => {
    try {
      const idParam = req.params.id;
      const id = Array.isArray(idParam) ? parseInt(idParam[0]) : parseInt(idParam);
      const campaign = await storage.getFundraisingCampaign(id);
      if (!campaign) {
        return res.status(404).json({ message: "Campaign not found" });
      }
      res.json(campaign);
    } catch (err) {
      console.error("Error fetching campaign:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create fundraising campaign (admin only)
  app.post("/api/fundraising", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { title, description, goalAmount, imageUrl, startDate, endDate, isActive } = req.body;
      const campaign = await storage.createFundraisingCampaign({
        title,
        description,
        goalAmount: Math.round(goalAmount * 100),
        imageUrl,
        startDate: startDate ? new Date(startDate) : null,
        endDate: endDate ? new Date(endDate) : null,
        isActive: isActive ?? true,
        createdBy: req.user!.id,
      });
      res.status(201).json(campaign);
    } catch (err) {
      console.error("Error creating campaign:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update fundraising campaign (admin only)
  app.put("/api/fundraising/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const idParam = req.params.id;
      const id = Array.isArray(idParam) ? parseInt(idParam[0]) : parseInt(idParam);
      const { title, description, goalAmount, imageUrl, startDate, endDate, isActive } = req.body;
      const campaign = await storage.updateFundraisingCampaign(id, {
        title,
        description,
        goalAmount: goalAmount ? Math.round(goalAmount * 100) : undefined,
        imageUrl,
        startDate: startDate ? new Date(startDate) : undefined,
        endDate: endDate ? new Date(endDate) : undefined,
        isActive,
      });
      res.json(campaign);
    } catch (err) {
      console.error("Error updating campaign:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete fundraising campaign (admin only)
  app.delete("/api/fundraising/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const idParam = req.params.id;
      const id = Array.isArray(idParam) ? parseInt(idParam[0]) : parseInt(idParam);
      await storage.deleteFundraisingCampaign(id);
      res.json({ message: "Campaign deleted" });
    } catch (err) {
      console.error("Error deleting campaign:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get user's donation history
  app.get("/api/donations/history", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const donations = await storage.getDonationHistory(userId);
      res.json(donations);
    } catch (err) {
      console.error("Error fetching donation history:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === DAILY DEVOTIONAL ROUTES ===

  // Get today's devotional (public)
  app.get("/api/devotionals/today", async (req, res) => {
    try {
      const devotional = await storage.getTodayDevotional();
      res.json(devotional);
    } catch (err) {
      console.error("Error fetching today's devotional:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all devotionals (public)
  app.get("/api/devotionals", async (req, res) => {
    try {
      const publishedOnly = req.query.published === "true";
      const devotionals = await storage.getDailyDevotionals(publishedOnly);
      res.json(devotionals);
    } catch (err) {
      console.error("Error fetching devotionals:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single devotional (public)
  app.get("/api/devotionals/:id", async (req, res) => {
    try {
      const idParam = req.params.id;
      const id = Array.isArray(idParam) ? parseInt(idParam[0]) : parseInt(idParam);
      const devotional = await storage.getDailyDevotional(id);
      if (!devotional) {
        return res.status(404).json({ message: "Devotional not found" });
      }
      res.json(devotional);
    } catch (err) {
      console.error("Error fetching devotional:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create devotional (admin only)
  app.post("/api/devotionals", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const devotional = await storage.createDailyDevotional({
        ...req.body,
        createdBy: req.user!.id,
      });
      res.status(201).json(devotional);
    } catch (err) {
      console.error("Error creating devotional:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update devotional (admin only)
  app.put("/api/devotionals/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const idParam = req.params.id;
      const id = Array.isArray(idParam) ? parseInt(idParam[0]) : parseInt(idParam);
      const devotional = await storage.updateDailyDevotional(id, req.body);
      res.json(devotional);
    } catch (err) {
      console.error("Error updating devotional:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete devotional (admin only)
  app.delete("/api/devotionals/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const idParam = req.params.id;
      const id = Array.isArray(idParam) ? parseInt(idParam[0]) : parseInt(idParam);
      await storage.deleteDailyDevotional(id);
      res.json({ message: "Devotional deleted" });
    } catch (err) {
      console.error("Error deleting devotional:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // AI-generated devotional (admin only)
  app.post("/api/devotionals/ai-generate", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { theme, bibleVerse, date } = req.body;
      
      // Template-based generation (can be replaced with actual AI API)
      const templates = [
        {
          title: `Walking in Faith: ${theme || "Daily Trust"}`,
          content: `Dear beloved, today we are reminded of the importance of walking by faith and not by sight. ${theme || "This theme"} speaks to the very heart of our Christian journey. When we trust in the Lord's plan, even when we cannot see the outcome, we demonstrate true faith.

Remember the words of Scripture: "For we walk by faith, not by sight." This means that our decisions, our actions, and our words should be guided by our belief in God's promises rather than our temporary circumstances.

As you go about your day, consider how you can apply this truth. Trust in the Lord's timing. He knows what is best for you. His plans are greater than ours.

Prayer: Lord, help me to walk in faith today. Give me the strength to trust You in all circumstances. In Jesus' name, amen.`,
          author: "AI Assistant",
          bibleVerse: bibleVerse || "2 Corinthians 5:7",
          theme: theme || "Faith",
        },
        {
          title: `The Power of God's Love: ${theme || "Experiencing Divine Love"}`,
          content: `God's love is greater than anything we can imagine. It is everlasting, unconditional, and eternal. Today, reflect on the depth of His love for you.

"He loved us and sent His Son to be the propitiation for our sins." This is the greatest demonstration of love the world has ever known.

In your relationships, seek to reflect this same love. Be patient, be kind, do not envy, do not boast, do not be proud. Love bears all things, believes all things, hopes all things, endures all things.

Prayer: Father, help me to understand and experience Your love more deeply each day. May I share this love with those around me. In Jesus' name, amen.`,
          author: "AI Assistant",
          bibleVerse: bibleVerse || "1 John 4:8",
          theme: theme || "Love",
        },
        {
          title: `Finding Peace in Troubled Times: ${theme || "God's Peace"}`,
          content: `In the midst of life's storms, God offers us a peace that surpasses all understanding. This peace is not dependent on our circumstances but on our relationship with Him.

"Be anxious for nothing, but in everything by prayer and supplication, with thanksgiving, let your requests be made known to God." When we bring our concerns to Him, He promises to guard our hearts and minds.

Whatever trial you face today, remember that God is with you. He will never leave you nor forsake you. Trust in His presence and find peace.

Prayer: Lord, grant me Your peace that surpasses all understanding. Help me to trust You in every circumstance. In Jesus' name, amen.`,
          author: "AI Assistant",
          bibleVerse: bibleVerse || "Philippians 4:6-7",
          theme: theme || "Peace",
        },
        {
          title: `Strength for Today: ${theme || "God's Sufficiency"}`,
          content: `Are you feeling weak or overwhelmed? God promises to be your strength. "The Lord is my shepherd; I shall not want." He supplies all our needs according to His riches in glory.

When you feel inadequate, remember that God's strength is made perfect in your weakness. His grace is sufficient for you. His power works best when yours runs out.

Take courage! The God who created the universe lives in you. He will give you the strength to face whatever comes your way today.

Prayer: Lord, be my strength and my shield. I trust in Your promises. Help me to lean on You in every situation. In Jesus' name, amen.`,
          author: "AI Assistant",
          bibleVerse: bibleVerse || "Philippians 4:13",
          theme: theme || "Strength",
        },
        {
          title: `Grace and Mercy: ${theme || "God's Unmerited Favor"}`,
          content: `God's grace and mercy are the foundations of our salvation. Grace is unmerited favorGod's goodness toward us despite our unworthiness. Mercy is God's compassion in not giving us what we deserve.

We all fall short of God's glory, but through Jesus Christ, we receive forgiveness and eternal life. This is the greatest gift anyone could ever receive.

Today, extend the same grace and mercy to others that God has extended to you. Forgive as you have been forgiven.

Prayer: Thank You, Lord, for Your amazing grace and mercy. Help me to extend the same to others. In Jesus' name, amen.`,
          author: "AI Assistant",
          bibleVerse: bibleVerse || "Ephesians 2:8-9",
          theme: theme || "Grace",
        },
      ];

      const randomTemplate = templates[Math.floor(Math.random() * templates.length)];
      const publishDate = date ? new Date(date) : new Date();
      
      const devotional = await storage.createDailyDevotional({
        ...randomTemplate,
        publishDate,
        isPublished: false,
        createdBy: req.user!.id,
      });

      res.status(201).json({
        devotional,
        message: "AI-generated devotional created. Review and publish when ready."
      });
    } catch (err) {
      console.error("Error generating devotional:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === BIBLE READING PLANS ROUTES ===

  // Get all reading plans (public)
  app.get("/api/reading-plans", async (req, res) => {
    try {
      const activeOnly = req.query.active === "true";
      const plans = await storage.getBibleReadingPlans(activeOnly);
      res.json(plans);
    } catch (err) {
      console.error("Error fetching reading plans:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single reading plan (public)
  app.get("/api/reading-plans/:id", async (req, res) => {
    try {
      const idParam = req.params.id;
      const id = Array.isArray(idParam) ? parseInt(idParam[0]) : parseInt(idParam);
      const plan = await storage.getBibleReadingPlan(id);
      if (!plan) {
        return res.status(404).json({ message: "Reading plan not found" });
      }
      res.json(plan);
    } catch (err) {
      console.error("Error fetching reading plan:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create reading plan (admin only)
  app.post("/api/reading-plans", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const plan = await storage.createBibleReadingPlan({
        ...req.body,
        createdBy: req.user!.id,
      });
      res.status(201).json(plan);
    } catch (err) {
      console.error("Error creating reading plan:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get user's reading progress
  app.get("/api/reading-plans/:id/progress", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const idParam = req.params.id;
      const id = Array.isArray(idParam) ? parseInt(idParam[0]) : parseInt(idParam);
      const userId = req.user!.id;
      const progress = await storage.getUserReadingProgress(userId, id);
      res.json(progress);
    } catch (err) {
      console.error("Error fetching reading progress:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Mark day as complete
  app.post("/api/reading-plans/:id/progress", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const idParam = req.params.id;
      const id = Array.isArray(idParam) ? parseInt(idParam[0]) : parseInt(idParam);
      const userId = req.user!.id;
      const { dayNumber } = req.body;
      
      if (!dayNumber) {
        return res.status(400).json({ message: "Day number is required" });
      }
      
      const progress = await storage.updateBibleReadingProgress(userId, id, dayNumber);
      res.json(progress);
    } catch (err) {
      console.error("Error updating reading progress:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === ATTENDANCE ROUTES ===

  // Get user's attendance history
  app.get("/api/attendance/me", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const attendanceRecords = await storage.getAttendanceByUser(userId);
      res.json(attendanceRecords);
    } catch (err) {
      console.error("Error fetching attendance:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Self check-in for a service
  app.post("/api/attendance/checkin", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const { serviceType, serviceId, serviceName, serviceDate, notes } = req.body;

      if (!serviceType || !serviceName || !serviceDate) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const existingAttendance = await storage.getUserAttendanceForService(
        userId,
        serviceType,
        new Date(serviceDate)
      );

      if (existingAttendance) {
        return res.status(400).json({ message: "Already checked in for this service" });
      }

      const attendance = await storage.createAttendance({
        userId,
        serviceType,
        serviceId: serviceId || null,
        serviceName,
        serviceDate: new Date(serviceDate),
        attendanceType: "SELF_CHECKIN",
        checkInTime: new Date(),
        isOnline: false,
        notes: notes || null,
        createdBy: userId,
      });

      res.status(201).json(attendance);
    } catch (err) {
      console.error("Error checking in:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Manual check-in (admin/leader only)
  app.post("/api/attendance/manual", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const { targetUserId, serviceType, serviceId, serviceName, serviceDate, notes } = req.body;

      if (!targetUserId || !serviceType || !serviceName || !serviceDate) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const existingAttendance = await storage.getUserAttendanceForService(
        targetUserId,
        serviceType,
        new Date(serviceDate)
      );

      if (existingAttendance) {
        return res.status(400).json({ message: "User already checked in for this service" });
      }

      const attendance = await storage.createAttendance({
        userId: targetUserId,
        serviceType,
        serviceId: serviceId || null,
        serviceName,
        serviceDate: new Date(serviceDate),
        attendanceType: "MANUAL",
        checkInTime: new Date(),
        isOnline: false,
        notes: notes || null,
        createdBy: userId,
      });

      res.status(201).json(attendance);
    } catch (err) {
      console.error("Error manual check-in:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Online attendance tracking - record watch session
  app.post("/api/attendance/online", async (req, res) => {
    try {
      const { userId, serviceType, serviceId, serviceName, serviceDate, watchDuration, isReplay } = req.body;

      if (!userId || !serviceType || !serviceName || !serviceDate) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const thresholdMinutes = parseInt(await storage.getAttendanceSetting("online_watch_threshold_minutes") || "10");
      const thresholdSeconds = thresholdMinutes * 60;

      if (watchDuration < thresholdSeconds) {
        return res.status(200).json({ message: "Watch time below threshold", recorded: false });
      }

      const existingAttendance = await storage.getUserAttendanceForService(
        userId,
        serviceType,
        new Date(serviceDate)
      );

      if (existingAttendance) {
        return res.status(200).json({ message: "Already recorded", recorded: true });
      }

      const attendance = await storage.createAttendance({
        userId,
        serviceType: isReplay ? "ONLINE_REPLAY" : "ONLINE_LIVE",
        serviceId: serviceId || null,
        serviceName,
        serviceDate: new Date(serviceDate),
        attendanceType: "ONLINE_AUTO",
        checkInTime: new Date(),
        watchDuration,
        isOnline: true,
        notes: null,
        createdBy: userId,
      });

      res.status(201).json(attendance);
    } catch (err) {
      console.error("Error recording online attendance:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Generate unique attendance link
  app.post("/api/attendance/links", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const { serviceType, serviceId, serviceName, serviceDate, expiresAt } = req.body;

      if (!serviceType || !serviceName || !serviceDate) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const token = crypto.randomBytes(32).toString("hex");
      const baseUrl = process.env.BASE_URL || `https://${req.get("host")}`;
      const checkinUrl = `${baseUrl}/attendance/checkin/${token}`;

      const link = await storage.createAttendanceLink({
        serviceType,
        serviceId: serviceId || null,
        serviceName,
        serviceDate: new Date(serviceDate),
        uniqueToken: token,
        qrCodeUrl: checkinUrl,
        isActive: true,
        expiresAt: expiresAt ? new Date(expiresAt) : null,
        createdBy: userId,
      });

      res.status(201).json({
        ...link,
        checkinUrl,
      });
    } catch (err) {
      console.error("Error creating attendance link:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get attendance by token (for check-in page)
  app.get("/api/attendance/links/:token", async (req, res) => {
    try {
      const tokenParam = req.params.token;
      const token = Array.isArray(tokenParam) ? tokenParam[0] : tokenParam;
      const link = await storage.getAttendanceLinkByToken(token);

      if (!link) {
        return res.status(404).json({ message: "Invalid or expired link" });
      }

      if (!link.isActive) {
        return res.status(400).json({ message: "This attendance link is no longer active" });
      }

      if (link.expiresAt && new Date(link.expiresAt) < new Date()) {
        return res.status(400).json({ message: "This attendance link has expired" });
      }

      res.json(link);
    } catch (err) {
      console.error("Error fetching attendance link:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Check-in via unique link (for members using attendance link)
  app.post("/api/attendance/links/:token/checkin", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const tokenParam = req.params.token;
      const token = Array.isArray(tokenParam) ? tokenParam[0] : tokenParam;
      const userId = req.user!.id;
      const { notes } = req.body;

      const link = await storage.getAttendanceLinkByToken(token);

      if (!link) {
        return res.status(404).json({ message: "Invalid or expired link" });
      }

      if (!link.isActive) {
        return res.status(400).json({ message: "This attendance link is no longer active" });
      }

      if (link.expiresAt && new Date(link.expiresAt) < new Date()) {
        return res.status(400).json({ message: "This attendance link has expired" });
      }

      const existingAttendance = await storage.getUserAttendanceForService(
        userId,
        link.serviceType,
        link.serviceDate
      );

      if (existingAttendance) {
        return res.status(400).json({ message: "Already checked in for this service" });
      }

      const attendance = await storage.createAttendance({
        userId,
        serviceType: link.serviceType,
        serviceId: link.serviceId,
        serviceName: link.serviceName,
        serviceDate: link.serviceDate,
        attendanceType: "QR_CHECKIN",
        checkInTime: new Date(),
        isOnline: false,
        notes: notes || null,
        createdBy: link.createdBy,
      });

      res.status(201).json(attendance);
    } catch (err) {
      console.error("Error checking in via link:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get attendance analytics (admin only)
  app.get("/api/attendance/analytics", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { startDate, endDate, serviceType } = req.query;

      if (!startDate || !endDate) {
        return res.status(400).json({ message: "Start date and end date are required" });
      }

      const stats = await storage.getAttendanceStats(
        new Date(startDate as string),
        new Date(endDate as string),
        serviceType as string | undefined
      );

      res.json(stats);
    } catch (err) {
      console.error("Error fetching attendance analytics:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get dashboard stats (admin only)
  app.get("/api/analytics/dashboard", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const stats = await storage.getDashboardStats();
      res.json(stats);
    } catch (err) {
      console.error("Error fetching dashboard stats:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get donation analytics (admin only)
  app.get("/api/analytics/donations", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { startDate, endDate } = req.query;

      const now = new Date();
      const start = startDate ? new Date(startDate as string) : new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      const end = endDate ? new Date(endDate as string) : now;

      const stats = await storage.getDonationAnalytics(start, end);
      res.json(stats);
    } catch (err) {
      console.error("Error fetching donation analytics:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get member growth analytics (admin only)
  app.get("/api/analytics/members", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { startDate, endDate } = req.query;

      const now = new Date();
      const start = startDate ? new Date(startDate as string) : new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      const end = endDate ? new Date(endDate as string) : now;

      const stats = await storage.getMemberGrowthAnalytics(start, end);
      res.json(stats);
    } catch (err) {
      console.error("Error fetching member growth analytics:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get event analytics (admin only)
  app.get("/api/analytics/events", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { startDate, endDate } = req.query;

      const now = new Date();
      const start = startDate ? new Date(startDate as string) : new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      const end = endDate ? new Date(endDate as string) : now;

      const stats = await storage.getEventAnalytics(start, end);
      res.json(stats);
    } catch (err) {
      console.error("Error fetching event analytics:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get prayer analytics (admin only)
  app.get("/api/analytics/prayers", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { startDate, endDate } = req.query;

      const now = new Date();
      const start = startDate ? new Date(startDate as string) : new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
      const end = endDate ? new Date(endDate as string) : now;

      const stats = await storage.getPrayerAnalytics(start, end);
      res.json(stats);
    } catch (err) {
      console.error("Error fetching prayer analytics:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all attendance records for a service (admin only)
  app.get("/api/attendance/service", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { serviceType, serviceDate } = req.query;

      if (!serviceType || !serviceDate) {
        return res.status(400).json({ message: "Service type and date are required" });
      }

      const records = await storage.getAttendanceByService(
        serviceType as string,
        new Date(serviceDate as string)
      );

      res.json(records);
    } catch (err) {
      console.error("Error fetching service attendance:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get attendance settings (admin only)
  app.get("/api/attendance/settings", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const settings = await storage.getAttendanceSetting("online_watch_threshold_minutes");
      res.json({
        onlineWatchThresholdMinutes: parseInt(settings || "10"),
        enableOnlineDetection: (await storage.getAttendanceSetting("enable_online_detection")) === "true",
        enableSelfCheckin: (await storage.getAttendanceSetting("enable_self_checkin")) === "true",
        enableQrCheckin: (await storage.getAttendanceSetting("enable_qr_checkin")) === "true",
      });
    } catch (err) {
      console.error("Error fetching attendance settings:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update attendance settings (admin only)
  app.put("/api/attendance/settings", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { onlineWatchThresholdMinutes, enableOnlineDetection, enableSelfCheckin, enableQrCheckin } = req.body;

      if (onlineWatchThresholdMinutes !== undefined) {
        await storage.updateAttendanceSetting("online_watch_threshold_minutes", String(onlineWatchThresholdMinutes));
      }
      if (enableOnlineDetection !== undefined) {
        await storage.updateAttendanceSetting("enable_online_detection", String(enableOnlineDetection));
      }
      if (enableSelfCheckin !== undefined) {
        await storage.updateAttendanceSetting("enable_self_checkin", String(enableSelfCheckin));
      }
      if (enableQrCheckin !== undefined) {
        await storage.updateAttendanceSetting("enable_qr_checkin", String(enableQrCheckin));
      }

      res.json({ message: "Settings updated successfully" });
    } catch (err) {
      console.error("Error updating attendance settings:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get absent members (admin + privileged roles)
  app.get("/api/attendance/absent", isAuthenticated, canViewAbsentMembers, async (req: AuthenticatedRequest, res) => {
    try {
      const consecutiveMissed = parseInt(req.query.consecutiveMissed as string) || 3;
      const absentMembers = await storage.getAbsentMembers(consecutiveMissed);
      res.json(absentMembers);
    } catch (err) {
      console.error("Error fetching absent members:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Send message to member (NO AUTH for testing)
  app.post("/api/messages/send", async (req: AuthenticatedRequest, res) => {
    console.log('=== MESSAGE SEND REQUEST (NO AUTH) ===');
    console.log('Body:', req.body);
    try {
      const { userId, type, title, content, priority } = req.body;
      
      if (!userId || !type || !title || !content) {
        return res.status(400).json({ message: "Missing required fields" });
      }

      const message = await storage.createMessage({
        userId,
        type,
        title,
        content,
        priority: priority || "normal",
        createdBy: req.user!.id,
      });

      // Mark user as contacted so they won't appear in absent list for 7 days
      await storage.markUserContacted(userId);

      sendNewMessageNotification(userId, message);

      res.status(201).json(message);
    } catch (err) {
      console.error("Error sending message:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get my messages
  app.get("/api/messages/me", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const messages = await storage.getUserMessages(userId);
      res.json(messages);
    } catch (err) {
      console.error("Error fetching messages:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get unread message count
  app.get("/api/messages/unread-count", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const count = await storage.getUnreadMessageCount(userId);
      res.json({ count });
    } catch (err) {
      console.error("Error fetching unread count:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Mark message as read
  app.put("/api/messages/:id/read", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const messageId = parseInt(req.params.id as string);
      await storage.markMessageAsRead(messageId);
      res.json({ success: true });
    } catch (err) {
      console.error("Error marking message as read:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Reply to message
  app.post("/api/messages/:id/reply", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const messageId = parseInt(req.params.id as string);
      const { content } = req.body;
      
      if (!content) {
        return res.status(400).json({ message: "Content is required" });
      }

      const reply = await storage.replyToMessage(
        messageId,
        req.user!.id,
        content,
        req.user!.id
      );

      res.status(201).json(reply);
    } catch (err) {
      console.error("Error replying to message:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get message thread
  app.get("/api/messages/:id/thread", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const messageId = parseInt(req.params.id as string);
      const thread = await storage.getMessageThread(messageId);
      res.json(thread);
    } catch (err) {
      console.error("Error getting message thread:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete old messages (can be called periodically)
  app.delete("/api/messages/cleanup", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const daysOld = parseInt(req.query.days as string) || 5;
      const deleted = await storage.deleteOldMessages(daysOld);
      res.json({ deleted, message: `Deleted ${deleted} messages older than ${daysOld} days` });
    } catch (err) {
      console.error("Error cleaning up messages:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Clean up old messages on startup (delete read messages older than 5 days)
  try {
    const deleted = await storage.deleteOldMessages(5);
    if (deleted > 0) {
      console.log(`Cleaned up ${deleted} old messages on startup`);
    }
  } catch (err) {
    console.error("Error cleaning up old messages on startup:", err);
  }

  // Seed data function
  try {
    await seedDatabase();
  } catch (err) {
    console.error("Error seeding database on startup:", err);
  }

  // === MUSIC LIBRARY ROUTES ===

  // Get all music tracks (public)
  app.get("/api/music", async (req, res) => {
    try {
      const publishedOnly = req.query.published === "true";
      const tracks = await storage.getMusic(publishedOnly);
      res.json(tracks);
    } catch (err) {
      console.error("Error fetching music:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single track
  app.get("/api/music/:id", async (req, res) => {
    try {
      const id = Number(req.params.id);
      const track = await storage.getMusicById(id);
      if (!track) {
        return res.status(404).json({ message: "Track not found" });
      }
      res.json(track);
    } catch (err) {
      console.error("Error fetching track:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create music track (admin only)
  app.post("/api/music", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { title, artist, album, genreId, duration, audioUrl, audioFilePath, coverImageUrl, lyrics, isPublished } = req.body;
      const track = await storage.createMusic({
        title,
        artist,
        album,
        genreId: genreId || null,
        duration: duration || null,
        audioUrl: audioUrl || null,
        audioFilePath: audioFilePath || null,
        coverImageUrl: coverImageUrl || null,
        lyrics: lyrics || null,
        isPublished: isPublished ?? false,
        createdBy: req.user!.id,
      });
      res.status(201).json(track);
    } catch (err) {
      console.error("Error creating track:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update music track (admin only)
  app.put("/api/music/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const { title, artist, album, genreId, duration, audioUrl, audioFilePath, coverImageUrl, lyrics, isPublished } = req.body;
      const track = await storage.updateMusic(id, {
        title,
        artist,
        album,
        genreId: genreId || null,
        duration: duration || null,
        audioUrl: audioUrl || null,
        audioFilePath: audioFilePath || null,
        coverImageUrl: coverImageUrl || null,
        lyrics: lyrics || null,
        isPublished,
      });
      res.json(track);
    } catch (err) {
      console.error("Error updating track:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete music track (admin only)
  app.delete("/api/music/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteMusic(id);
      res.json({ message: "Track deleted" });
    } catch (err) {
      console.error("Error deleting track:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Increment play count (public - for tracking)
  app.post("/api/music/:id/play", async (req, res) => {
    try {
      const id = Number(req.params.id);
      const track = await storage.incrementMusicPlayCount(id);
      res.json({ message: "Play count updated", playCount: track.playCount });
    } catch (err) {
      console.error("Error updating play count:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get music genres
  app.get("/api/music/genres", async (req, res) => {
    try {
      const genres = await storage.getMusicGenres();
      res.json(genres);
    } catch (err) {
      console.error("Error fetching genres:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create music genre (admin only)
  app.post("/api/music/genres", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { name, description } = req.body;
      if (!name) {
        return res.status(400).json({ message: "Genre name is required" });
      }
      const genre = await storage.createMusicGenre(name, description);
      res.status(201).json(genre);
    } catch (err) {
      console.error("Error creating genre:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete music genre (admin only)
  app.delete("/api/music/genres/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteMusicGenre(id);
      res.json({ message: "Genre deleted" });
    } catch (err) {
      console.error("Error deleting genre:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get playlists
  app.get("/api/music/playlists", async (req, res) => {
    try {
      const userId = req.query.userId as string;
      const playlists = await storage.getMusicPlaylists(userId);
      res.json(playlists);
    } catch (err) {
      console.error("Error fetching playlists:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single playlist with tracks
  app.get("/api/music/playlists/:id", async (req, res) => {
    try {
      const id = Number(req.params.id);
      const playlist = await storage.getMusicPlaylistById(id);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      const tracks = await storage.getPlaylistTracks(id);
      res.json({ ...playlist, tracks });
    } catch (err) {
      console.error("Error fetching playlist:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create playlist (authenticated users)
  app.post("/api/music/playlists", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const { name, description, coverImageUrl, isPublic } = req.body;
      if (!name) {
        return res.status(400).json({ message: "Playlist name is required" });
      }
      const playlist = await storage.createMusicPlaylist({
        name,
        description: description || null,
        coverImageUrl: coverImageUrl || null,
        userId: req.user!.id,
        isPublic: isPublic ?? false,
      });
      res.status(201).json(playlist);
    } catch (err) {
      console.error("Error creating playlist:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update playlist
  app.put("/api/music/playlists/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const playlist = await storage.getMusicPlaylistById(id);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      if (playlist.userId !== req.user!.id && !req.user!.isAdmin) {
        return res.status(403).json({ message: "Not authorized to update this playlist" });
      }
      const { name, description, coverImageUrl, isPublic } = req.body;
      const updated = await storage.updateMusicPlaylist(id, {
        name: name || playlist.name,
        description: description !== undefined ? description : playlist.description,
        coverImageUrl: coverImageUrl !== undefined ? coverImageUrl : playlist.coverImageUrl,
        isPublic: isPublic !== undefined ? isPublic : playlist.isPublic,
      });
      res.json(updated);
    } catch (err) {
      console.error("Error updating playlist:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete playlist
  app.delete("/api/music/playlists/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const playlist = await storage.getMusicPlaylistById(id);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      if (playlist.userId !== req.user!.id && !req.user!.isAdmin) {
        return res.status(403).json({ message: "Not authorized to delete this playlist" });
      }
      await storage.deleteMusicPlaylist(id);
      res.json({ message: "Playlist deleted" });
    } catch (err) {
      console.error("Error deleting playlist:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Add track to playlist
  app.post("/api/music/playlists/:id/tracks", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const playlistId = Number(req.params.id);
      const playlist = await storage.getMusicPlaylistById(playlistId);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      if (playlist.userId !== req.user!.id && !req.user!.isAdmin) {
        return res.status(403).json({ message: "Not authorized to modify this playlist" });
      }
      const { musicId } = req.body;
      if (!musicId) {
        return res.status(400).json({ message: "Music ID is required" });
      }
      await storage.addMusicToPlaylist(playlistId, musicId);
      res.json({ message: "Track added to playlist" });
    } catch (err) {
      console.error("Error adding track to playlist:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Remove track from playlist
  app.delete("/api/music/playlists/:id/tracks/:musicId", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const playlistId = Number(req.params.id);
      const musicId = Number(req.params.musicId);
      const playlist = await storage.getMusicPlaylistById(playlistId);
      if (!playlist) {
        return res.status(404).json({ message: "Playlist not found" });
      }
      if (playlist.userId !== req.user!.id && !req.user!.isAdmin) {
        return res.status(403).json({ message: "Not authorized to modify this playlist" });
      }
      await storage.removeMusicFromPlaylist(playlistId, musicId);
      res.json({ message: "Track removed from playlist" });
    } catch (err) {
      console.error("Error removing track from playlist:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === HOUSE CELL COMMUNITY ROUTES ===

  // Get all house cells (public)
  app.get("/api/house-cells", async (req, res) => {
    try {
      const activeOnly = req.query.active === "true";
      const cells = await storage.getHouseCells(activeOnly);
      res.json(cells);
    } catch (err) {
      console.error("Error fetching house cells:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single house cell
  app.get("/api/house-cells/:id", async (req, res) => {
    try {
      const id = Number(req.params.id);
      const cell = await storage.getHouseCellById(id);
      if (!cell) {
        return res.status(404).json({ message: "House cell not found" });
      }
      res.json(cell);
    } catch (err) {
      console.error("Error fetching house cell:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create house cell (admin only)
  app.post("/api/house-cells", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { name, description, leaderId, leaderName, leaderPhone, address, city, state, country, meetingDay, meetingTime, isActive } = req.body;
      if (!name || !address) {
        return res.status(400).json({ message: "Name and address are required" });
      }
      const cell = await storage.createHouseCell({
        name,
        description: description || null,
        leaderId: leaderId || null,
        leaderName: leaderName || null,
        leaderPhone: leaderPhone || null,
        address,
        city: city || null,
        state: state || null,
        country: country || null,
        meetingDay: meetingDay || null,
        meetingTime: meetingTime || null,
        isActive: isActive ?? true,
        createdBy: req.user!.id,
      });
      res.status(201).json(cell);
    } catch (err) {
      console.error("Error creating house cell:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update house cell (admin only)
  app.put("/api/house-cells/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const { name, description, leaderId, leaderName, leaderPhone, address, city, state, country, meetingDay, meetingTime, isActive } = req.body;
      const cell = await storage.updateHouseCell(id, {
        name,
        description,
        leaderId,
        leaderName,
        leaderPhone,
        address,
        city,
        state,
        country,
        meetingDay,
        meetingTime,
        isActive,
      });
      res.json(cell);
    } catch (err) {
      console.error("Error updating house cell:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete house cell (admin only)
  app.delete("/api/house-cells/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteHouseCell(id);
      res.json({ message: "House cell deleted" });
    } catch (err) {
      console.error("Error deleting house cell:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get house cell members
  app.get("/api/house-cells/:id/members", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const cell = await storage.getHouseCellById(id);
      if (!cell) {
        return res.status(404).json({ message: "House cell not found" });
      }
      const members = await storage.getHouseCellMembers(id);
      res.json(members);
    } catch (err) {
      console.error("Error fetching house cell members:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Assign user to house cell (admin only)
  app.post("/api/house-cells/:id/members", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const houseCellId = Number(req.params.id);
      const { userId } = req.body;
      if (!userId) {
        return res.status(400).json({ message: "User ID is required" });
      }
      const cell = await storage.getHouseCellById(houseCellId);
      if (!cell) {
        return res.status(404).json({ message: "House cell not found" });
      }
      const user = await storage.assignUserToHouseCell(userId, houseCellId);
      res.json(user);
    } catch (err) {
      console.error("Error assigning user to house cell:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Remove user from house cell (admin only)
  app.delete("/api/house-cells/:id/members/:userId", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const userIdParam = req.params.userId;
      const userId = Array.isArray(userIdParam) ? userIdParam[0] : userIdParam;
      const user = await storage.removeUserFromHouseCell(userId);
      res.json(user);
    } catch (err) {
      console.error("Error removing user from house cell:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get house cell messages
  app.get("/api/house-cells/:id/messages", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const cell = await storage.getHouseCellById(id);
      if (!cell) {
        return res.status(404).json({ message: "House cell not found" });
      }
      const messages = await storage.getHouseCellMessages(id);
      res.json(messages);
    } catch (err) {
      console.error("Error fetching house cell messages:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Send message to house cell
  app.post("/api/house-cells/:id/messages", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const houseCellId = Number(req.params.id);
      const { content } = req.body;
      if (!content) {
        return res.status(400).json({ message: "Message content is required" });
      }
      const cell = await storage.getHouseCellById(houseCellId);
      if (!cell) {
        return res.status(404).json({ message: "House cell not found" });
      }
      const message = await storage.createHouseCellMessage({
        houseCellId,
        userId: req.user!.id,
        content,
      });
      res.status(201).json(message);
    } catch (err) {
      console.error("Error creating house cell message:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get user's house cell
  app.get("/api/house-cells/my", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const user = await storage.getUserById(req.user!.id);
      if (!user || !user.houseCellId) {
        return res.status(404).json({ message: "You are not assigned to a house cell" });
      }
      const cell = await storage.getHouseCellById(user.houseCellId);
      res.json(cell);
    } catch (err) {
      console.error("Error fetching user's house cell:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === GROUP SPACE ROUTES ===

  // Get all groups (public - shows public groups)
  app.get("/api/groups", async (req, res) => {
    try {
      const allGroups = await storage.getGroups();
      const publicGroups = allGroups.filter(g => !g.isPrivate);
      res.json(publicGroups);
    } catch (err) {
      console.error("Error fetching groups:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get user's groups
  app.get("/api/groups/my", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const userGroups = await storage.getUserGroups(req.user!.id);
      res.json(userGroups);
    } catch (err) {
      console.error("Error fetching user groups:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single group
  app.get("/api/groups/:id", async (req, res) => {
    try {
      const id = Number(req.params.id);
      const group = await storage.getGroupById(id);
      if (!group) {
        return res.status(404).json({ message: "Group not found" });
      }
      res.json(group);
    } catch (err) {
      console.error("Error fetching group:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create group
  app.post("/api/groups", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const { name, description, coverImageUrl, isPrivate, allowMemberInvite } = req.body;
      if (!name) {
        return res.status(400).json({ message: "Group name is required" });
      }
      const group = await storage.createGroup({
        name,
        description: description || null,
        coverImageUrl: coverImageUrl || null,
        createdBy: req.user!.id,
        isPrivate: isPrivate ?? false,
        allowMemberInvite: allowMemberInvite ?? true,
      });
      
      // Add creator as admin member
      await storage.addGroupMember({
        groupId: group.id,
        userId: req.user!.id,
        role: "ADMIN",
      });
      
      res.status(201).json(group);
    } catch (err) {
      console.error("Error creating group:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update group
  app.put("/api/groups/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const group = await storage.getGroupById(id);
      if (!group) {
        return res.status(404).json({ message: "Group not found" });
      }
      if (group.createdBy !== req.user!.id && !req.user!.isAdmin) {
        return res.status(403).json({ message: "Not authorized" });
      }
      const { name, description, coverImageUrl, isPrivate, allowMemberInvite } = req.body;
      const updated = await storage.updateGroup(id, {
        name: name || group.name,
        description: description !== undefined ? description : group.description,
        coverImageUrl: coverImageUrl !== undefined ? coverImageUrl : group.coverImageUrl,
        isPrivate: isPrivate !== undefined ? isPrivate : group.isPrivate,
        allowMemberInvite: allowMemberInvite !== undefined ? allowMemberInvite : group.allowMemberInvite,
      });
      res.json(updated);
    } catch (err) {
      console.error("Error updating group:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete group
  app.delete("/api/groups/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const group = await storage.getGroupById(id);
      if (!group) {
        return res.status(404).json({ message: "Group not found" });
      }
      if (group.createdBy !== req.user!.id && !req.user!.isAdmin) {
        return res.status(403).json({ message: "Not authorized" });
      }
      await storage.deleteGroup(id);
      res.json({ message: "Group deleted" });
    } catch (err) {
      console.error("Error deleting group:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get group members
  app.get("/api/groups/:id/members", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const members = await storage.getGroupMembers(id);
      res.json(members);
    } catch (err) {
      console.error("Error fetching members:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Join group
  app.post("/api/groups/:id/join", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const group = await storage.getGroupById(id);
      if (!group) {
        return res.status(404).json({ message: "Group not found" });
      }
      if (group.isPrivate) {
        return res.status(403).json({ message: "This group is private" });
      }
      await storage.addGroupMember({
        groupId: id,
        userId: req.user!.id,
        role: "MEMBER",
      });
      res.json({ message: "Joined group successfully" });
    } catch (err) {
      console.error("Error joining group:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Leave group
  app.post("/api/groups/:id/leave", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.removeGroupMember(id, req.user!.id);
      res.json({ message: "Left group successfully" });
    } catch (err) {
      console.error("Error leaving group:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get group messages
  app.get("/api/groups/:id/messages", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const messages = await storage.getGroupMessages(id);
      res.json(messages);
    } catch (err) {
      console.error("Error fetching messages:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Send group message
  app.post("/api/groups/:id/messages", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const { content } = req.body;
      if (!content) {
        return res.status(400).json({ message: "Message content is required" });
      }
      const group = await storage.getGroupById(id);
      if (!group) {
        return res.status(404).json({ message: "Group not found" });
      }
      const message = await storage.createGroupMessage({
        groupId: id,
        userId: req.user!.id,
        content,
      });
      res.status(201).json(message);
    } catch (err) {
      console.error("Error sending message:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === AUDIT LOGS & PERMISSIONS ===

  // Get audit logs (admin only)
  app.get("/api/audit-logs", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 100;
      const logs = await storage.getAuditLogs(limit);
      res.json(logs);
    } catch (err) {
      console.error("Error fetching audit logs:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper function to log admin actions
  const logAdminAction = async (userId: string, action: string, entityType: string, entityId: string, details?: any) => {
    try {
      await storage.createAuditLog({
        userId,
        action,
        entityType,
        entityId,
        details,
      });
    } catch (err) {
      console.error("Error logging admin action:", err);
    }
  };

  // Get user's permissions based on role
  app.get("/api/permissions", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const user = await storage.getUserById(req.user!.id);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }

      // Role to permissions mapping
      const rolePermissions: Record<string, string[]> = {
        ADMIN: ['manage_members', 'manage_events', 'manage_sermons', 'manage_donations', 'manage_finance', 'manage_groups', 'manage_attendance', 'send_messages', 'view_analytics', 'manage_settings', 'manage_content', 'moderate_content'],
        PASTOR: ['manage_members', 'manage_events', 'manage_sermons', 'manage_groups', 'manage_attendance', 'send_messages', 'view_analytics', 'manage_content', 'moderate_content'],
        PASTORS_WIFE: ['manage_members', 'manage_events', 'manage_sermons', 'manage_groups', 'send_messages', 'view_analytics', 'manage_content'],
        CELL_LEADER: ['manage_attendance', 'send_messages', 'view_analytics'],
        USHERS_LEADER: ['manage_attendance', 'send_messages'],
        FINANCE_TEAM: ['manage_donations', 'manage_finance', 'view_analytics'],
        PRAYER_TEAM: ['moderate_content'],
        TECH_TEAM: ['manage_sermons', 'manage_events'],
        MEMBER: [],
        USER: [],
      };

      const permissions = rolePermissions[user.role] || rolePermissions.MEMBER;
      res.json({
        role: user.role,
        permissions,
        isAdmin: user.email === 'admin@wccrm.com',
      });
    } catch (err) {
      console.error("Error fetching permissions:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === LIVE STREAMING ROUTES ===

  // Get all live streams (public)
  app.get("/api/live-streams", async (req, res) => {
    try {
      const streams = await storage.getLiveStreams();
      res.json(streams);
    } catch (err) {
      console.error("Error fetching live streams:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get current live stream (public)
  app.get("/api/live-streams/current", async (req, res) => {
    try {
      const stream = await storage.getCurrentLiveStream();
      res.json(stream || null);
    } catch (err) {
      console.error("Error fetching current live stream:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single live stream (public)
  app.get("/api/live-streams/:id", async (req, res) => {
    try {
      const id = Number(req.params.id);
      const stream = await storage.getLiveStream(id);
      if (!stream) {
        return res.status(404).json({ message: "Live stream not found" });
      }
      res.json(stream);
    } catch (err) {
      console.error("Error fetching live stream:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Start a live stream (admin only)
  app.post("/api/live-streams", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { title, description, streamUrl, embedUrl, youtubeVideoId, youtubeChannelId, youtubeChannelName } = req.body;
      
      // End any currently live streams first
      const currentStream = await storage.getCurrentLiveStream();
      if (currentStream) {
        await storage.updateLiveStream(currentStream.id, { isLive: false });
      }

      const stream = await storage.createLiveStream({
        title,
        description,
        streamUrl,
        embedUrl,
        youtubeVideoId,
        youtubeChannelId,
        youtubeChannelName,
        isLive: true,
        createdBy: req.user!.id,
      });

      res.status(201).json(stream);
    } catch (err) {
      console.error("Error creating live stream:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update a live stream (admin only)
  app.put("/api/live-streams/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const { title, description, streamUrl, embedUrl, isLive } = req.body;
      
      const stream = await storage.getLiveStream(id);
      if (!stream) {
        return res.status(404).json({ message: "Live stream not found" });
      }

      const updated = await storage.updateLiveStream(id, {
        title: title ?? stream.title,
        description: description ?? stream.description,
        streamUrl: streamUrl ?? stream.streamUrl,
        embedUrl: embedUrl ?? stream.embedUrl,
        isLive: isLive ?? stream.isLive,
      });

      res.json(updated);
    } catch (err) {
      console.error("Error updating live stream:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // End a live stream (admin only)
  app.post("/api/live-streams/:id/end", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      
      const stream = await storage.getLiveStream(id);
      if (!stream) {
        return res.status(404).json({ message: "Live stream not found" });
      }

      const updated = await storage.updateLiveStream(id, { isLive: false });
      res.json(updated);
    } catch (err) {
      console.error("Error ending live stream:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete a live stream (admin only)
  app.delete("/api/live-streams/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteLiveStream(id);
      res.json({ message: "Live stream deleted" });
    } catch (err) {
      console.error("Error deleting live stream:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === API Keys Routes (for External Integrations) ===
  
  // Get user's API keys
  app.get("/api/keys", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const keys = await storage.getApiKeys(req.user.id);
      res.json(keys.map(k => ({ ...k, key: k.key ? `${k.prefix}_${k.key.substring(0, 8)}...` : null })));
    } catch (err) {
      console.error("Error getting API keys:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create API key
  app.post("/api/keys", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const { name, permissions = ["read"], rateLimit = 100, expiresAt } = req.body;
      
      // Generate random API key
      const key = crypto.randomBytes(32).toString("hex");
      const prefix = "wccrm";
      
      const apiKey = await storage.createApiKey({
        userId: req.user.id,
        name,
        key,
        prefix,
        permissions,
        rateLimit,
        expiresAt: expiresAt ? new Date(expiresAt) : null,
        isActive: true,
      });
      
      res.json({ ...apiKey, key: `${prefix}_${key}` });
    } catch (err) {
      console.error("Error creating API key:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete API key
  app.delete("/api/keys/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteApiKey(id);
      res.json({ message: "API key deleted" });
    } catch (err) {
      console.error("Error deleting API key:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Toggle API key
  app.patch("/api/keys/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const { isActive } = req.body;
      const updated = await storage.updateApiKey(id, { isActive });
      res.json(updated);
    } catch (err) {
      console.error("Error updating API key:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === Webhooks Routes ===
  
  // Get user's webhooks
  app.get("/api/webhooks", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const webhooks = await storage.getWebhooks(req.user.id);
      res.json(webhooks);
    } catch (err) {
      console.error("Error getting webhooks:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create webhook
  app.post("/api/webhooks", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const { url, events, secret } = req.body;
      
      if (!url || !events || !Array.isArray(events)) {
        return res.status(400).json({ message: "URL and events array are required" });
      }
      
      const webhook = await storage.createWebhook({
        userId: req.user!.id,
        url,
        events,
        secret: secret || crypto.randomBytes(32).toString("hex"),
        isActive: true,
      });
      
      res.json(webhook);
    } catch (err) {
      console.error("Error creating webhook:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update webhook
  app.patch("/api/webhooks/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const { url, events, isActive } = req.body;
      const updates: any = {};
      if (url) updates.url = url;
      if (events) updates.events = events;
      if (typeof isActive === "boolean") updates.isActive = isActive;
      
      const updated = await storage.updateWebhook(id, updates);
      res.json(updated);
    } catch (err) {
      console.error("Error updating webhook:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete webhook
  app.delete("/api/webhooks/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteWebhook(id);
      res.json({ message: "Webhook deleted" });
    } catch (err) {
      console.error("Error deleting webhook:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === Public API (for external integrations with API key) ===
  
  // Rate limiting map
  const rateLimitMap = new Map<string, { count: number; resetTime: number }>();

  // Middleware to check API key
  const requireApiKey = async (req: any, res: any, next: any) => {
    const apiKeyHeader = req.headers["x-api-key"];
    
    if (!apiKeyHeader) {
      return res.status(401).json({ message: "API key required" });
    }
    
    // Parse key prefix and key
    const [prefix, key] = apiKeyHeader.split("_");
    
    if (!prefix || !key) {
      return res.status(401).json({ message: "Invalid API key format" });
    }
    
    // Find API key in database
    const storedKey = await storage.getApiKeyByKey(key);
    
    if (!storedKey) {
      return res.status(401).json({ message: "Invalid API key" });
    }
    
    if (!storedKey.isActive) {
      return res.status(403).json({ message: "API key is inactive" });
    }
    
    if (storedKey.expiresAt && new Date(storedKey.expiresAt) < new Date()) {
      return res.status(403).json({ message: "API key has expired" });
    }
    
    // Check rate limit
    const now = Date.now();
    const rateLimitKey = `${storedKey.id}`;
    const rateLimitData = rateLimitMap.get(rateLimitKey);
    
    if (rateLimitData && rateLimitData.resetTime > now) {
      const limit = storedKey.rateLimit ?? 100;
      if (rateLimitData.count >= limit) {
        return res.status(429).json({ message: "Rate limit exceeded" });
      }
      rateLimitData.count++;
    } else {
      // Reset rate limit (1 hour)
      rateLimitMap.set(rateLimitKey, { count: 1, resetTime: now + 3600000 });
    }
    
    // Update last used
    await storage.updateApiKey(storedKey.id, { lastUsedAt: new Date() });
    
    // Attach API key to request
    req.apiKey = storedKey;
    next();
  };

  // Public API: Get events
  app.get("/api/public/events", requireApiKey, async (req, res) => {
    try {
      const events = await storage.getEvents();
      res.json(events);
    } catch (err) {
      console.error("Error fetching events:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Public API: Get sermons
  app.get("/api/public/sermons", requireApiKey, async (req, res) => {
    try {
      const sermons = await storage.getSermons();
      res.json(sermons);
    } catch (err) {
      console.error("Error fetching sermons:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Public API: Get prayer requests
  app.get("/api/public/prayers", requireApiKey, async (req, res) => {
    try {
      const prayers = await storage.getPrayerRequests();
      res.json(prayers);
    } catch (err) {
      console.error("Error fetching prayers:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === Volunteer Management Routes ===
  
  // Get volunteer skills
  app.get("/api/volunteer/skills", async (req, res) => {
    try {
      const skills = await storage.getVolunteerSkills();
      res.json(skills);
    } catch (err) {
      console.error("Error getting volunteer skills:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create volunteer skill (admin only)
  app.post("/api/volunteer/skills", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { name, description, category } = req.body;
      const skill = await storage.createVolunteerSkill({ name, description, category });
      res.json(skill);
    } catch (err) {
      console.error("Error creating volunteer skill:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get volunteer profile
  app.get("/api/volunteer/profile", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      let profile = await storage.getVolunteerProfile(req.user.id);
      
      // Create profile if doesn't exist
      if (!profile) {
        profile = await storage.createVolunteerProfile({
          userId: req.user.id,
          isActive: true,
        });
      }
      
      res.json(profile);
    } catch (err) {
      console.error("Error getting volunteer profile:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update volunteer profile
  app.patch("/api/volunteer/profile", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const { skills, availability, isActive } = req.body;
      const updates: any = {};
      if (skills) updates.skills = skills;
      if (availability) updates.availability = availability;
      if (typeof isActive === "boolean") updates.isActive = isActive;
      
      let profile = await storage.getVolunteerProfile(req.user.id);
      if (!profile) {
        profile = await storage.createVolunteerProfile({ userId: req.user.id, ...updates });
      } else {
        profile = await storage.updateVolunteerProfile(req.user.id, updates);
      }
      res.json(profile);
    } catch (err) {
      console.error("Error updating volunteer profile:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get volunteer opportunities
  app.get("/api/volunteer/opportunities", async (req, res) => {
    try {
      const activeOnly = req.query.active !== "false";
      const opportunities = await storage.getVolunteerOpportunities(activeOnly);
      res.json(opportunities);
    } catch (err) {
      console.error("Error getting volunteer opportunities:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create volunteer opportunity (admin only)
  app.post("/api/volunteer/opportunities", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const { title, description, requiredSkills, date, duration, location, spotsAvailable } = req.body;
      const opportunity = await storage.createVolunteerOpportunity({
        title,
        description,
        requiredSkills: requiredSkills || [],
        date: new Date(date),
        duration,
        location,
        spotsAvailable,
        createdBy: req.user.id,
        isActive: true,
      });
      res.json(opportunity);
    } catch (err) {
      console.error("Error creating volunteer opportunity:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update volunteer opportunity (admin only)
  app.patch("/api/volunteer/opportunities/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const { title, description, requiredSkills, date, duration, location, spotsAvailable, isActive } = req.body;
      const updates: any = {};
      if (title) updates.title = title;
      if (description) updates.description = description;
      if (requiredSkills) updates.requiredSkills = requiredSkills;
      if (date) updates.date = new Date(date);
      if (duration) updates.duration = duration;
      if (location) updates.location = location;
      if (spotsAvailable) updates.spotsAvailable = spotsAvailable;
      if (typeof isActive === "boolean") updates.isActive = isActive;
      
      const opportunity = await storage.updateVolunteerOpportunity(id, updates);
      res.json(opportunity);
    } catch (err) {
      console.error("Error updating volunteer opportunity:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete volunteer opportunity (admin only)
  app.delete("/api/volunteer/opportunities/:id", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteVolunteerOpportunity(id);
      res.json({ message: "Opportunity deleted" });
    } catch (err) {
      console.error("Error deleting volunteer opportunity:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get my volunteer assignments
  app.get("/api/volunteer/assignments", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const assignments = await storage.getVolunteerAssignments(req.user.id);
      res.json(assignments);
    } catch (err) {
      console.error("Error getting volunteer assignments:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Sign up for volunteer opportunity
  app.post("/api/volunteer/assignments", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const { opportunityId } = req.body;
      
      const opportunity = await storage.getVolunteerOpportunity(opportunityId);
      if (!opportunity) {
        return res.status(404).json({ message: "Opportunity not found" });
      }
      
      if (opportunity.spotsAvailable && (opportunity.spotsFilled ?? 0) >= opportunity.spotsAvailable) {
        return res.status(400).json({ message: "No spots available" });
      }
      
      const assignment = await storage.createVolunteerAssignment({
        volunteerId: req.user.id,
        opportunityId,
        status: "pending",
      });
      
      res.json(assignment);
    } catch (err) {
      console.error("Error signing up for volunteer opportunity:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update assignment status (e.g., check-in)
  app.patch("/api/volunteer/assignments/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const { status, checkInAt, checkOutAt, notes } = req.body;
      const updates: any = {};
      if (status) updates.status = status;
      if (checkInAt) updates.checkInAt = new Date(checkInAt);
      if (checkOutAt) updates.checkOutAt = new Date(checkOutAt);
      if (notes) updates.notes = notes;
      
      const assignment = await storage.updateVolunteerAssignment(id, updates);
      res.json(assignment);
    } catch (err) {
      console.error("Error updating volunteer assignment:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get volunteer badges
  app.get("/api/volunteer/badges", async (req, res) => {
    try {
      const badges = await storage.getVolunteerBadges();
      res.json(badges);
    } catch (err) {
      console.error("Error getting volunteer badges:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create volunteer badge (admin only)
  app.post("/api/volunteer/badges", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { name, description, icon, criteria } = req.body;
      const badge = await storage.createVolunteerBadge({ name, description, icon, criteria });
      res.json(badge);
    } catch (err) {
      console.error("Error creating volunteer badge:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get user's badges
  app.get("/api/volunteer/my-badges", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const badges = await storage.getUserBadges(req.user.id);
      res.json(badges);
    } catch (err) {
      console.error("Error getting user badges:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

// Award badge to user (admin only)
  app.post("/api/volunteer/award-badge", isAuthenticated, isAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { userId, badgeId } = req.body;
      const badge = await storage.awardBadge(userId, badgeId);
      res.json(badge);
    } catch (err) {
      console.error("Error awarding badge:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // === Bible Study Routes ===

  // Get user's highlights
  app.get("/api/bible/highlights", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const highlights = await storage.getUserHighlights(req.user.id);
      res.json(highlights);
    } catch (err) {
      console.error("Error getting highlights:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create highlight
  app.post("/api/bible/highlights", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const { book, chapter, verse, color, note } = req.body;
      const highlight = await storage.createUserHighlight({
        userId: req.user.id,
        book,
        chapter,
        verse,
        color: color || "#FFEB3B",
        note,
      });
      res.json(highlight);
    } catch (err) {
      console.error("Error creating highlight:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete highlight
  app.delete("/api/bible/highlights/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteUserHighlight(id);
      res.json({ message: "Highlight deleted" });
    } catch (err) {
      console.error("Error deleting highlight:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get user's notes
  app.get("/api/bible/notes", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const notes = await storage.getUserNotes(req.user.id);
      res.json(notes);
    } catch (err) {
      console.error("Error getting notes:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create note
  app.post("/api/bible/notes", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const { book, chapter, verse, content } = req.body;
      const note = await storage.createUserNote({
        userId: req.user.id,
        book,
        chapter,
        verse,
        content,
      });
      res.json(note);
    } catch (err) {
      console.error("Error creating note:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update note
  app.patch("/api/bible/notes/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      const { content } = req.body;
      const note = await storage.updateUserNote(id, { content });
      res.json(note);
    } catch (err) {
      console.error("Error updating note:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete note
  app.delete("/api/bible/notes/:id", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteUserNote(id);
      res.json({ message: "Note deleted" });
    } catch (err) {
      console.error("Error deleting note:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get verse discussions (public)
  app.get("/api/bible/discussions", async (req, res) => {
    try {
      const { book, chapter, verse } = req.query;
      if (!book || !chapter || !verse) {
        return res.status(400).json({ message: "book, chapter, and verse are required" });
      }
      const discussions = await storage.getVerseDiscussions(
        book as string,
        parseInt(chapter as string),
        parseInt(verse as string)
      );
      res.json(discussions);
    } catch (err) {
      console.error("Error getting discussions:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create verse discussion (authenticated)
  app.post("/api/bible/discussions", isAuthenticated, async (req: AuthenticatedRequest, res) => {
    try {
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const { book, chapter, verse, content } = req.body;
      const discussion = await storage.createVerseDiscussion({
        userId: req.user.id,
        book,
        chapter,
        verse,
        content,
      });
      res.json(discussion);
    } catch (err) {
      console.error("Error creating discussion:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  return httpServer;
}

async function seedDatabase() {
  const existingSermons = await storage.getSermons();
  if (existingSermons.length === 0) {
    await storage.createSermon({
      title: "The Power of Community",
      speaker: "Pastor John Doe",
      date: new Date(),
      description: "Discover why we need each other to grow in faith.",
      series: "Better Together",
      topic: "Community",
      videoUrl: "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
      isUpcoming: false,
      thumbnailUrl:
        "https://images.unsplash.com/photo-1438232992991-995b7058bbb3?w=800&auto=format&fit=crop&q=60",
    });
    await storage.createSermon({
      title: "Finding Peace in Chaos",
      speaker: "Pastor Jane Smith",
      date: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
      description: "How to maintain inner peace when the world is crazy.",
      series: "Peace of Mind",
      topic: "Peace",
      isUpcoming: false,
      thumbnailUrl:
        "https://images.unsplash.com/photo-1507692049790-de58293a4697?w=800&auto=format&fit=crop&q=60",
    });
    await storage.createSermon({
      title: "Walking in Faith",
      speaker: "Pastor Emmanuel Moses",
      date: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      description: "Learning to trust God in every step of our journey.",
      series: "Faith Journey",
      topic: "Faith",
      isUpcoming: true,
      thumbnailUrl:
        "https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=800&auto=format&fit=crop&q=60",
    });
  } else {
    for (const sermon of existingSermons) {
      await storage.updateSermon(sermon.id, { date: new Date(Date.now() - (sermon.id - 1) * 7 * 24 * 60 * 60 * 1000) });
    }
  }

  const existingEvents = await storage.getEvents();
  if (existingEvents.length === 0) {
    await storage.createEvent({
      title: "Sunday Service",
      description: "Join us for worship and a message.",
      date: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),
      location: "Main Sanctuary",
      imageUrl:
        "https://images.unsplash.com/photo-1478147427282-58a87a120781?w=800&auto=format&fit=crop&q=60",
    });
    await storage.createEvent({
      title: "Youth Group Night",
      description: "Fun, games, and fellowship for teens.",
      date: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
      location: "Youth Hall",
      imageUrl:
        "https://images.unsplash.com/photo-1523580494863-6f3031224c94?w=800&auto=format&fit=crop&q=60",
    });
  } else {
    const eventDates = [
      new Date(Date.now() + 2 * 24 * 60 * 60 * 1000),
      new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
      new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    ];
    for (let i = 0; i < existingEvents.length; i++) {
      await storage.updateEvent(existingEvents[i].id, { date: eventDates[i] || eventDates[0] });
    }
  }
}
